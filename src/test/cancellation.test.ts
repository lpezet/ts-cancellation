import { CancellationToken, CancellationTokenSource } from "@this/cancellation";
import { resolveCaa } from "dns";

describe("cancellation", () => {

    test("basic", (): void => {
        const source = new CancellationTokenSource();
        const token = source.token;
        expect(token).not.toBeNull();
        expect(token.canceled).toBeFalsy();
        expect(token.canBeCanceled).toBeTruthy();
        token.throwIfCanceled("should not be thrown since not yet canceled.");
        source.cancel("error generated by test.");
        expect(token.canceled).toBeTruthy();
        expect(token.canBeCanceled).toBeFalsy();
        var thrown = true;
        try {
            token.throwIfCanceled("This should be thrown (yet caught) because this token was canceled. Key to find: a1b2c3d4.");
            thrown = false;
        } catch (err: any) {
            // this is good
            expect(err).toContain("a1b2c3d4");
        }
        if (!thrown) {
            fail("Should be throwing error since it was canceled.");
        }
    });

    // https://docs.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads?redirectedfrom=MSDN#listening-by-registering-a-callback
    test("listening by registering callback", (): Promise<any> => {

        function sleep(ms: number, token: CancellationToken) {
            return new Promise<void>((resolve, reject) => {
                const subscription = token.subscribe(err => {
                    clearTimeout(handle);
                    resolve();
                });
                const handle = setTimeout(() => {
                    subscription.unsubscribe()
                    reject(new Error("Expected to be cancelled."));
                }, ms);
            });
        }
        const source = new CancellationTokenSource();
        setTimeout(() => source.cancel(), 10);
        return sleep(100, source.token);
    });

    // https://docs.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads?redirectedfrom=MSDN#listening-by-polling
    test("listening by polling", (): Promise<any> => {
        const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));
        function asyncWork(ms: number, token: CancellationToken): Promise<void> {
            return new Promise<void>(async (resolve, reject) => {
                for (var i = 0; i < 10; i++) {
                    await sleep(ms); // simulating work
                    if (token.canceled) {
                        //reject(new Error(`Cancellation requested at ${i}`)); // typical usage
                        resolve(); // expected to be canceled
                        return;
                    }
                }
                console.log("#### Resolved!")
                //resolve(); // typical usage
                reject(new Error("Expected to be canceled before finishing."))
            });

        }
        const source = new CancellationTokenSource();
        setTimeout(() => source.cancel(), 50);
        return asyncWork(15, source.token);
    });

    // https://docs.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads?redirectedfrom=MSDN#listening-by-polling
    test("listening to multiple tokens simultaneously", (): Promise<any> => {
        const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));
        const internalSource = new CancellationTokenSource();
        const internalToken = internalSource.token;

        function asyncWork(ms: number, externalToken: CancellationToken): Promise<void> {
            // assuming here the externalToken is within this unit of work
            const linkedSources = new CancellationTokenSource([internalToken, externalToken]);
            return new Promise<void>(async (resolve, reject) => {
                for (var i = 0; i < 10; i++) {
                    await sleep(ms); // simulating work
                    if (internalToken.canceled) {
                        console.log("Operation timed out.")
                        //reject(new Error(`Cancellation requested at ${i}`)); // typical usage
                        resolve(); // expected to be canceled
                        return;
                    }
                    if (externalToken.canceled) {
                        console.log("Cancellation requested by user.")
                        resolve();
                        return;
                    }
                }
                //resolve(); // typical usage
                reject(new Error("Expected to be canceled before finishing."))
            });

        }
        const externalSource = new CancellationTokenSource();
        setTimeout(() => externalSource.cancel(), 50);
        return asyncWork(15, externalSource.token);
    });

    test("subscription", () => {
        var called = false;
        const callback = (reason: any): void => {
            called = true;
        }
        const source = new CancellationTokenSource();
        source.subscribe(callback);
        source.cancel(new Error("Some dumy reason to cancel."));
        expect(called).toBeTruthy();
    });

    test("unsubscribe", () => {
        var called = false;
        const callback = (reason: any): void => {
            called = true;
        }
        const source = new CancellationTokenSource();
        const subscription = source.subscribe(callback);
        subscription.unsubscribe();
        source.cancel(new Error("Some dumy reason to cancel."));
        expect(called).toBeFalsy();
    });

    test("links", () => {
        const source1 = new CancellationTokenSource();
        const source2 = new CancellationTokenSource();
        const source = new CancellationTokenSource([source1.token, source2.token]);

        expect(source1.token.canceled).toBeFalsy();
        expect(source2.token.canceled).toBeFalsy();
        expect(source.token.canceled).toBeFalsy();

        source1.cancel(new Error("Dummy error to test links."));

        expect(source1.token.canceled).toBeTruthy();
        expect(source2.token.canceled).toBeFalsy();
        expect(source.token.canceled).toBeTruthy();

    });

    test("close", () => {
        const source1 = new CancellationTokenSource();
        const source2 = new CancellationTokenSource();
        const source = new CancellationTokenSource([source1.token, source2.token]);

        expect(source1.token.canceled).toBeFalsy();
        expect(source2.token.canceled).toBeFalsy();
        expect(source.token.canceled).toBeFalsy();

        source.close();
        source1.cancel(new Error("Dummy error after close."));

        expect(source1.token.canceled).toBeTruthy();
        expect(source.token.canceled).toBeFalsy();
        expect(source2.token.canceled).toBeFalsy();

    });

});
